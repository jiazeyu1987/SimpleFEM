# SimpleFEM 核心算法详解

## 绿线检测算法

### HSV颜色空间过滤

绿线检测的核心是利用HSV颜色空间对绿色进行精确识别：

```python
def hsv_green_detection(image):
    # RGB转HSV
    hsv = cv2.cvtColor(image, cv2.COLOR_BGR2HSV)

    # 绿色HSV范围定义
    lower_green = np.array([35, 80, 80])   # H:色调, S:饱和度, V:明度
    upper_green = np.array([85, 255, 255])

    # 创建绿色掩码
    mask = cv2.inRange(hsv, lower_green, upper_green)

    return mask
```

**HSV参数解析**：
- **H (色相)**: 35-85，覆盖从黄绿色到青绿色的范围
- **S (饱和度)**: 80-255，确保颜色饱和度足够，避免灰白色干扰
- **V (明度)**: 80-255，排除过暗的像素

### Canny边缘检测参数

```python
def canny_edge_detection(mask):
    edges = cv2.Canny(
        mask,            # 输入图像
        50,              # 低阈值 (弱边缘)
        150,             # 高阈值 (强边缘)
        apertureSize=3   # Sobel算子大小
    )
    return edges
```

**参数原理**：
- **低阈值50**: 小于此值的梯度被抑制
- **高阈值150**: 大于此值的梯度被视为强边缘
- **双阈值机制**: 强边缘保留，弱边缘只有在连接强边缘时才保留

### 霍夫直线变换

```python
def hough_line_detection(edges):
    lines = cv2.HoughLinesP(
        edges,              # 边缘图像
        rho=1,              # 距离分辨率 (1像素精度)
        theta=np.pi/180,    # 角度分辨率 (1度精度)
        threshold=50,       # 累加器阈值 (最少50个点共线)
        minLineLength=80,   # 最小线段长度
        maxLineGap=20       # 最大线段间隙
    )
    return lines
```

**算法原理**：
- **霍夫变换**: 将图像空间的点映射到参数空间的线
- **累加器**: 记录每个(ρ,θ)参数组合的投票数
- **峰值检测**: 找到得票最多的参数组合，对应主要直线

### 交点计算算法

```python
def compute_intersection(line1, line2):
    x1, y1, x2, y2 = line1
    x3, y3, x4, y4 = line2

    # 计算两条直线的交点
    # 使用行列式方法求解线性方程组
    denom = (x1-x2)*(y3-y4) - (y1-y2)*(x3-x4)

    if abs(denom) < 1e-10:  # 平行或近似平行
        return None

    # 交点坐标公式
    t = ((x1-x3)*(y3-y4) - (y1-y3)*(x3-x4)) / denom
    intersection_x = x1 + t * (x2-x1)
    intersection_y = y1 + t * (y2-y1)

    return (intersection_x, intersection_y)
```

## 波峰检测算法

### 自适应阈值算法

```python
def adaptive_threshold_update(current_gray, current_threshold,
                             bg_sum, bg_count, threshold_ratio=0.15):
    # 只在当前值低于阈值时更新背景均值 (防止波峰污染)
    if current_gray < current_threshold:
        bg_sum += current_gray
        bg_count += 1
        bg_mean = bg_sum / bg_count

        # 自适应阈值 = 背景均值 × (1 + 上浮比例)
        adaptive_threshold = bg_mean * (1 + threshold_ratio)
        return adaptive_threshold, bg_mean, bg_sum, bg_count

    return current_threshold, bg_mean, bg_sum, bg_count
```

**设计原理**：
- **门控更新机制**: 只有低于阈值的值才能参与背景计算，避免波峰数据污染
- **历史均值**: 使用足够多的背景样本计算可靠的基准
- **动态阈值**: 根据背景变化自动调整检测敏感度

### 波峰区域识别算法

```python
def identify_peak_regions(curve, threshold, margin_frames=5, silence_frames=15):
    n = len(curve)
    raw_peaks = []
    in_peak = False
    start = 0

    # 第一步：识别连续的高位区间
    for i, value in enumerate(curve):
        if value >= threshold:
            if not in_peak:
                start = i
                in_peak = True
        else:
            if in_peak:
                raw_peaks.append((start, i-1))
                in_peak = False

    # 处理序列末尾的波峰
    if in_peak:
        raw_peaks.append((start, n-1))

    # 第二步：应用最小间隔过滤
    if margin_frames > 0:
        filtered_peaks = []
        for i, (s1, e1) in enumerate(raw_peaks):
            if i == 0:
                filtered_peaks.append((s1, e1))
            else:
                s2, e2 = filtered_peaks[-1]
                if s1 - e2 >= margin_frames:
                    filtered_peaks.append((s1, e1))
                else:
                    # 保留峰值更高的波峰
                    max1 = max(curve[s1:e1+1])
                    max2 = max(curve[s2:e2+1])
                    if max1 > max2:
                        filtered_peaks[-1] = (s1, e1)
        raw_peaks = filtered_peaks

    # 第三步：应用静默约束
    if silence_frames > 0:
        final_peaks = []
        for s, e in raw_peaks:
            # 检查边界条件
            if s - silence_frames < 0 or e + silence_frames >= n:
                continue

            # 检查前置静默期
            pre_silence_ok = all(curve[i] < threshold
                               for i in range(s - silence_frames, s))

            # 检查后置静默期
            post_silence_ok = all(curve[i] < threshold
                                for i in range(e + 1, e + 1 + silence_frames))

            if pre_silence_ok and post_silence_ok:
                final_peaks.append((s, e))
        raw_peaks = final_peaks

    return raw_peaks
```

**多层过滤机制**：
1. **阈值过滤**: 基础的高度要求
2. **间隔过滤**: 确保波峰之间有足够的分离
3. **静默约束**: 波峰前后必须有足够的低位区间

### 绿/红波峰分类算法

```python
def classify_peaks_by_frame_difference(curve, peaks,
                                     difference_threshold=2.1,
                                     avg_frames=5):
    green_peaks = []
    red_peaks = []

    for start, end in peaks:
        # 计算波峰前后的均值差
        frame_diff = calculate_frame_difference(
            curve, start, end, avg_frames
        )

        # 分类判断
        if frame_diff >= difference_threshold:
            green_peaks.append((start, end))
        else:
            red_peaks.append((start, end))

    return green_peaks, red_peaks

def calculate_frame_difference(curve, start, end, avg_frames):
    n = len(curve)

    # 计算波峰前的均值 (边界处理)
    pre_start = max(0, start - avg_frames)
    pre_values = curve[pre_start:start]
    pre_avg = sum(pre_values) / len(pre_values) if pre_values else curve[start]

    # 计算波峰后的均值 (边界处理)
    post_end = min(n, end + 1 + avg_frames)
    post_values = curve[end + 1:post_end]
    post_avg = sum(post_values) / len(post_values) if post_values else curve[end]

    return post_avg - pre_avg
```

**分类原理**：
- **绿色波峰**: 波峰后灰度值显著高于波峰前 (signal上升趋势)
- **红色波峰**: 波峰前后灰度值差异不大 (signal平稳或下降)
- **差异阈值**: 经验值，需要根据具体应用场景调整

## 去重算法

### 连续帧窗口去重

```python
def consecutive_frame_deduplication(new_peaks, existing_peaks,
                                   window_size=10):
    filtered_peaks = []

    for new_peak in new_peaks:
        is_duplicate = False

        for existing_peak in existing_peaks:
            # 检查是否在去重窗口内
            if abs(new_peak.frame_index - existing_peak.frame_index) <= window_size:
                # 检查是否为同类型波峰
                if new_peak.peak_type == existing_peak.peak_type:
                    # 比较峰值强度，保留更强的
                    if new_peak.peak_value <= existing_peak.peak_value:
                        is_duplicate = True
                        break
                    else:
                        # 替换掉较弱的波峰
                        filtered_peaks = [
                            p for p in filtered_peaks
                            if abs(p.frame_index - existing_peak.frame_index) > window_size
                        ]

        if not is_duplicate:
            filtered_peaks.append(new_peak)

    return filtered_peaks
```

**去重策略**：
- **时间窗口**: 在指定帧数窗口内的同类型波峰被认为是重复的
- **强度优先**: 保留峰值强度更高的波峰
- **类型一致**: 只有相同类型的波峰才会被去重

## 性能优化算法

### 循环缓冲区实现

```python
class CircularBuffer:
    def __init__(self, max_size):
        self.buffer = [0.0] * max_size
        self.max_size = max_size
        self.head = 0
        self.count = 0

    def append(self, value):
        self.buffer[self.head] = value
        self.head = (self.head + 1) % self.max_size
        if self.count < self.max_size:
            self.count += 1

    def get_recent(self, n):
        if n > self.count:
            n = self.count

        recent = []
        for i in range(n):
            idx = (self.head - 1 - i) % self.max_size
            recent.append(self.buffer[idx])

        return recent[::-1]  # 返回按时间正序的列表
```

**优化原理**：
- **固定内存**: 避免动态内存分配和释放
- **O(1)插入**: 常数时间复杂度的数据添加
- **就地覆盖**: 新数据自动覆盖最旧的数据

### 直方图快速灰度计算

```python
def fast_average_gray(image):
    """使用直方图快速计算平均灰度值"""
    # 转换为灰度图
    gray = image.convert("L")

    # 计算直方图 (O(N)时间，但后续操作很快)
    histogram = gray.histogram()

    # 计算加权和 (O(256)时间，常数复杂度)
    total_sum = 0
    total_pixels = 0

    for gray_value, count in enumerate(histogram):
        if count > 0:
            total_sum += gray_value * count
            total_pixels += count

    return total_sum / total_pixels if total_pixels > 0 else 0.0
```

**算法优势**：
- **单次遍历**: 只需遍历图像一次计算直方图
- **快速求和**: 利用直方图特性，256次固定操作完成求和
- **内存效率**: 不需要存储所有像素值

这些核心算法构成了 SimpleFEM 的技术基础，确保了系统在医学信号检测中的准确性和可靠性。