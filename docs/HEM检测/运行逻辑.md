# SimpleFEM 运行逻辑文档

## 概述

SimpleFEM 是一个独立的 HEM (高回声事件) 检测守护进程，通过计算机视觉和信号处理技术实时监测医学信号中的波峰事件。程序支持屏幕实时捕获和视频文件处理两种模式。

## 主程序架构

### 程序入口点
- **主模块**: `simple_roi_daemon.py`
- **入口函数**: `run_daemon()` (第252行)
- **运行方式**:
  ```bash
  python simple_roi_daemon.py
  # 或运行编译后的可执行文件
  dist\SimpleFEM_ROI_Daemon.exe
  ```

### 核心处理循环
程序以固定帧率（配置可调，默认10 FPS）持续执行以下处理循环：

```python
def run_daemon():
    # 1. 初始化配置和资源
    config = load_fem_config()
    logger = setup_peak_logger()

    # 2. 根据配置选择输入源
    if config["processing_mode"] == "video":
        video_cap = initialize_video_capture(config["video_processing"]["video_path"])

    # 3. 主处理循环
    while True:
        # 获取帧 (屏幕或视频)
        if processing_mode == "screen":
            roi1_image = capture_screen_roi()
        else:
            roi1_image = get_video_frame(video_cap, loop_enabled)

        # 执行完整的处理流水线
        process_frame(roi1_image, frame_index)

        # 帧率控制
        time.sleep(1.0 / frame_rate)
        frame_index += 1
```

## 详细处理流水线

### 第1步：图像获取与ROI处理

#### 屏幕捕获模式
```python
def capture_screen_roi():
    # 使用 PIL.ImageGrab 抓取屏幕
    screen_image = ImageGrab.grab()

    # 调整ROI1坐标到屏幕边界内
    x1, y1, x2, y2 = adjust_roi1_to_screen(screen_size, roi_config)

    # 裁剪ROI1区域
    roi1_image = screen_image.crop((x1, y1, x2, y2))
    return roi1_image
```

#### 视频文件模式
```python
def get_video_frame(video_cap, loop_enabled=False):
    # 读取视频帧
    ret, frame = video_cap.read()

    # 视频结束处理
    if not ret and loop_enabled:
        video_cap.set(cv2.CAP_PROP_POS_FRAMES, 0)  # 重置到开始
        ret, frame = video_cap.read()

    # 转换颜色空间
    rgb_frame = cv2.cvtColor(frame, cv2.COLOR_BGR2RGB)
    return Image.fromarray(rgb_frame)
```

### 第2步：绿线交点检测

使用 OpenCV 进行绿线检测：

```python
def detect_green_intersection(roi1_image):
    # HSV颜色空间过滤
    hsv = cv2.cvtColor(roi1_array, cv2.COLOR_BGR2HSV)
    lower_green = np.array([35, 80, 80])
    upper_green = np.array([85, 255, 255])
    mask_green = cv2.inRange(hsv, lower_green, upper_green)

    # 边缘检测
    edges = cv2.Canny(mask_green, 50, 150, apertureSize=3)

    # 霍夫变换检测直线
    lines = cv2.HoughLinesP(edges, rho=1, theta=np.pi/180,
                           threshold=50, minLineLength=80, maxLineGap=20)

    # 选择两条主要的非平行线
    # 计算交点
    intersection = compute_line_intersection(line1, line2)
    return intersection
```

**检测参数**：
- HSV范围：H[35-85], S[80-255], V[80-255]
- 霍夫变换阈值：50
- 最小线段长度：80像素
- 最大线段间隙：20像素

### 第3步：ROI2区域提取

围绕绿线交点提取小范围ROI2：

```python
def extract_roi2_around_intersection(roi1_image, intersection_point, extension_params):
    cx, cy = intersection_point
    left = extension_params["left"]   # 默认20像素
    right = extension_params["right"] # 默认30像素
    top = extension_params["top"]     # 默认60像素
    bottom = extension_params["bottom"] # 默认20像素

    # 计算ROI2坐标 (相对于ROI1)
    x1 = cx - left
    y1 = cy - top
    x2 = cx + right
    y2 = cy + bottom

    # 边界限制和裁剪
    roi2_region = clamp_to_bounds(roi1_size, x1, y1, x2, y2)
    roi2_image = roi1_image.crop(roi2_region)
    return roi2_image, roi2_region
```

### 第4步：灰度值计算与缓冲

```python
def compute_average_gray(image):
    # 转换为灰度图
    gray = image.convert("L")

    # 计算直方图加权和
    histogram = gray.histogram()
    total_sum = sum(value * count for value, count in enumerate(histogram))
    total_pixels = gray.width * gray.height

    return float(total_sum / total_pixels)
```

**数据缓冲机制**：
- 使用 `collections.deque` 实现固定长度循环缓冲区
- 缓冲区大小：100帧
- 新数据从右侧添加，旧数据从左侧移除

```python
gray_buffer = deque(maxlen=100)
gray_buffer.append(roi2_gray_value)
```

### 第5步：自适应阈值波峰检测

#### 阈值计算策略
```python
def adaptive_threshold_calculation():
    # 背景均值更新 (仅当当前值低于阈值时更新，避免波峰污染)
    if current_gray < current_threshold:
        background_sum += current_gray
        background_count += 1
        bg_mean = background_sum / background_count

    # 自适应阈值计算
    if background_count >= min_samples:
        adaptive_threshold = bg_mean * (1 + threshold_over_mean_ratio)
    else:
        adaptive_threshold = fixed_threshold  # 回退到固定阈值

    return adaptive_threshold, bg_mean
```

#### 波峰区域识别
```python
def detect_peak_regions(curve, threshold, margin_frames, silence_frames):
    raw_peaks = []
    in_peak = False
    start = 0

    # 识别连续的高位区间
    for i, value in enumerate(curve):
        if value >= threshold:
            if not in_peak:
                start = i
                in_peak = True
        else:
            if in_peak:
                raw_peaks.append((start, i-1))
                in_peak = False

    # 处理末尾的波峰
    if in_peak:
        raw_peaks.append((start, len(curve)-1))

    # 应用最小间隔过滤
    filtered_peaks = apply_margin_filter(raw_peaks, margin_frames)

    # 应用静默约束
    final_peaks = apply_silence_constraint(filtered_peaks, silence_frames)

    return final_peaks
```

#### 绿/红波峰分类
```python
def classify_peaks(curve, peaks, difference_threshold, avg_frames=5):
    green_peaks = []
    red_peaks = []

    for start, end in peaks:
        # 计算波峰前后的均值差
        frame_diff = calculate_frame_difference(curve, start, end, avg_frames)

        # 分类判断
        if frame_diff >= difference_threshold:
            green_peaks.append((start, end))
        else:
            red_peaks.append((start, end))

    return green_peaks, red_peaks

def calculate_frame_difference(curve, start, end, avg_frames):
    # 计算波峰前N帧均值
    pre_start = max(0, start - avg_frames)
    pre_avg = sum(curve[pre_start:start]) / (start - pre_start)

    # 计算波峰后N帧均值
    post_end = min(len(curve), end + 1 + avg_frames)
    post_avg = sum(curve[end+1:post_end]) / (post_end - (end + 1))

    return post_avg - pre_avg
```

### 第6步：统计与数据导出

#### 去重机制
```python
def deduplicate_peaks(new_peaks, consecutive_window):
    # 基于连续帧窗口的同色波峰去重
    # 同色波峰在窗口内只保留峰值更高的一个
    filtered_peaks = []
    for peak in new_peaks:
        if not is_duplicate(peak, filtered_peaks, consecutive_window):
            filtered_peaks.append(peak)

    return filtered_peaks
```

#### CSV数据导出
```python
def export_peak_statistics():
    # 生成会话ID
    session_id = f"{datetime.now().strftime('%Y%m%d_%H%M%S')}"

    # 导出文件路径
    export_path = f"exports/hem_peaks_{session_id}.csv"

    # CSV格式：时间戳, 帧索引, 波峰类型, 开始帧, 结束帧, 灰度值, 交点坐标, ROI2信息
    with open(export_path, 'w', encoding='utf-8') as f:
        writer = csv.writer(f)
        writer.writerow(['timestamp', 'frame_index', 'peak_type', 'start_frame', 'end_frame',
                        'gray_value', 'intersection_x', 'intersection_y', 'roi2_region'])

        for peak in processed_peaks:
            writer.writerow(peak.to_csv_row())

    return export_path
```

## 配置系统

### 配置文件层次结构
```json
{
  "processing_mode": "video",        // "screen" 或 "video"
  "data_processing": {
    "save_roi1": true,              // 保存大ROI图像
    "save_roi2": true,              // 保存小ROI图像
    "save_wave": true,              // 保存波形图
    "only_delect": true             // 仅保存有波峰的帧
  },
  "video_processing": {
    "video_path": "123.mp4",        // 视频文件路径
    "loop_enabled": false,          // 是否循环播放
    "processing_frame_rate": 10.0   // 处理帧率
  },
  "roi_capture": {
    "frame_rate": 10,               // ROI捕获帧率
    "default_config": {
      "x1": 1280, "y1": 80,        // ROI1坐标
      "x2": 1920, "y2": 980
    },
    "roi2_config": {
      "extension_params": {
        "left": 20, "right": 30,   // ROI2扩展参数
        "top": 60, "bottom": 20
      }
    }
  },
  "peak_detection": {
    "threshold": 95.0,                      // 固定阈值
    "margin_frames": 5,                     // 峰间最小间隔
    "silence_frames": 15,                   // 静默约束长度
    "pre_post_avg_frames": 5,               // 前后均值计算窗口
    "adaptive_threshold_enabled": true,     // 启用自适应阈值
    "threshold_over_mean_ratio": 0.15,      // 阈值上浮比例15%
    "history_mean_min_samples": 30,         // 自适应阈值生效最小样本数
    "difference_threshold": 2.1,            // 绿/红判定阈值
    "min_region_length": 5                  // 最小波峰宽度
  }
}
```

### 环境变量支持
程序支持通过 `NHEM_*` 前缀的环境变量覆盖配置：
- `NHEM_THRESHOLD`: 覆盖检测阈值
- `NHEM_FPS`: 覆盖处理帧率
- `NHEM_PROCESSING_MODE`: 覆盖处理模式

## 错误处理与资源管理

### 异常处理策略
```python
def main():
    try:
        run_daemon()
    except KeyboardInterrupt:
        # 优雅停止：导出最终数据
        export_final_csv()
    except Exception as e:
        # 错误恢复：尝试保存已有数据
        try:
            export_final_csv()
        except:
            pass
        logging.error(f"守护进程错误: {e}")
    finally:
        # 资源清理
        if video_cap:
            video_cap.release()
        cv2.destroyAllWindows()
```

### 资源管理
- **内存管理**: 使用固定大小循环缓冲区防止内存泄漏
- **文件句柄**: 使用上下文管理器确保文件正确关闭
- **视频资源**: 程序结束或异常时自动释放视频捕获器
- **日志轮转**: 按天自动轮转日志文件，保留7天历史

## 性能特征

### 处理性能指标
- **帧率**: 1-10 FPS (可配置)
- **延迟**: <100ms/帧 (典型ROI尺寸)
- **内存使用**: 固定大小缓冲区，无内存泄漏
- **CPU使用**: 主要消耗在图像处理和波峰检测

### 优化策略
- **循环缓冲区**: 避免动态内存分配
- **边界检查**: 坐标裁剪防止越界
- **异常隔离**: 单帧处理失败不影响整体运行
- **资源池**: 减少重复的对象创建开销

## 数据输出

### 文件输出结构
```
SimpleFEM/
├── logs/
│   └── roi_peak_daemon.log          # 运行日志
├── exports/
│   └── hem_peaks_YYYYMMDD_HHMMSS.csv  # 波峰数据导出
├── roi1/                            # ROI1图像 (可选)
├── roi2/                            # ROI2图像 (可选)
└── wave/                            # 波形图 (可选)
```

### CSV数据格式
每行包含完整的波峰信息：
```csv
timestamp,frame_index,peak_type,start_frame,end_frame,gray_value,intersection_x,intersection_y,roi2_info
2024-01-15 14:30:25,123,green,120,125,112.5,45,78,"x1:25,y1:58,x2:75,y2:108"
```

这份运行逻辑文档详细描述了 SimpleFEM 程序的完整处理流程，为开发和维护提供了全面的技术参考。