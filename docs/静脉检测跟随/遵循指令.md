# 遵循指令功能文档

## 概述

"遵循指令"是VeinDetector系统中的一种自动化工作模式，允许系统按照预设的参数和算法流程自动进行静脉检测分析。该功能可以减少人工干预，提高检测的一致性和效率，特别适用于批量处理和标准化检测场景。

## 功能描述

### 核心特性
1. **自动化执行**: 系统自动使用预配置参数进行分析
2. **算法锁定**: 在遵循指令期间，参数调整功能被禁用
3. **状态管理**: 清晰的开始/暂停/结束状态指示
4. **UI适配**: 界面元素根据遵循指令状态动态调整
5. **结果一致性**: 确保相同输入产生一致的分析结果

### 工作流程
```
开始遵循指令 → 锁定参数设置 → 自动执行分析 → 实时显示结果 → 结束遵循指令 → 恢复手动控制
```

## 前端实现

### 状态管理

```typescript
// 遵循指令状态枚举
enum FollowInstructionState {
  IDLE = 'idle',           // 空闲状态
  RUNNING = 'running',     // 正在执行
  PAUSED = 'paused',       // 已暂停
  COMPLETED = 'completed'  // 已完成
}

// 状态管理接口
interface FollowInstructionState {
  isActive: boolean;       // 是否处于遵循指令状态
  currentAlgorithm: string; // 当前使用的算法
  parameters: Record<string, any>; // 锁定的参数
  startTime?: Date;        // 开始时间
  progress: number;        // 进度百分比
}
```

### UI组件状态控制

```typescript
// 按钮状态控制
const FollowInstructionControls = () => {
  const { state, startFollowInstruction, stopFollowInstruction } = useFollowInstruction();

  return (
    <div className="flex items-center space-x-4">
      {/* 开始分析按钮 - 遵循指令时隐藏 */}
      {!state.isActive && (
        <Button
          onClick={() => startFollowInstruction()}
          className="bg-blue-600 hover:bg-blue-700"
        >
          开始分析
        </Button>
      )}

      {/* 遵循指令状态指示器 */}
      {state.isActive && (
        <div className="flex items-center space-x-2">
          <div className="w-3 h-3 bg-green-500 rounded-full animate-pulse"></div>
          <span className="text-sm font-medium">遵循指令中</span>
          <Button
            onClick={() => stopFollowInstruction()}
            variant="outline"
            size="sm"
          >
            结束
          </Button>
        </div>
      )}
    </div>
  );
};
```

### 参数锁定机制

```typescript
// 参数控制组件
const ParameterControls = ({ algorithm, parameters, onParameterChange }) => {
  const { isFollowInstructionActive } = useFollowInstruction();

  return (
    <div className={`space-y-4 ${isFollowInstructionActive ? 'opacity-50 pointer-events-none' : ''}`}>
      {/* 阈值滑块 */}
      <Slider
        value={parameters.threshold}
        onChange={(value) => onParameterChange('threshold', value)}
        disabled={isFollowInstructionActive}
        min={0}
        max={255}
        step={1}
        label="阈值"
      />

      {/* 其他参数控制 */}
      <Slider
        value={parameters.morph_strength}
        onChange={(value) => onParameterChange('morph_strength', value)}
        disabled={isFollowInstructionActive}
        min={0}
        max={1}
        step={0.1}
        label="形态学强度"
      />

      {/* 参数锁定指示器 */}
      {isFollowInstructionActive && (
        <div className="mt-4 p-3 bg-yellow-50 border border-yellow-200 rounded-md">
          <p className="text-sm text-yellow-800">
            ⚠️ 遵循指令模式：参数已锁定
          </p>
        </div>
      )}
    </div>
  );
};
```

## 后端实现

### API接口扩展

```python
# main.py 中的相关端点
from fastapi import FastAPI, HTTPException
from pydantic import BaseModel

class FollowInstructionRequest(BaseModel):
    algorithm: str
    parameters: Dict[str, Any]
    enable: bool

class FollowInstructionResponse(BaseModel):
    success: bool
    message: str
    session_id: Optional[str] = None

# 遵循指令控制端点
@app.post("/api/follow-instruction")
async def follow_instruction(request: FollowInstructionRequest):
    """
    控制遵循指令模式
    """
    try:
        if request.enable:
            # 开始遵循指令
            session_id = start_follow_instruction_session(
                algorithm=request.algorithm,
                parameters=request.parameters
            )
            return FollowInstructionResponse(
                success=True,
                message="遵循指令已启动",
                session_id=session_id
            )
        else:
            # 结束遵循指令
            stop_follow_instruction_session()
            return FollowInstructionResponse(
                success=True,
                message="遵循指令已结束"
            )
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))

# 获取当前遵循指令状态
@app.get("/api/follow-instruction/status")
async def get_follow_instruction_status():
    """
    获取当前遵循指令状态
    """
    return get_current_follow_instruction_status()
```

### 会话管理

```python
# follow_instruction_manager.py
import uuid
from typing import Dict, Optional, Any
from datetime import datetime

class FollowInstructionSession:
    def __init__(self, algorithm: str, parameters: Dict[str, Any]):
        self.session_id = str(uuid.uuid4())
        self.algorithm = algorithm
        self.parameters = parameters.copy()  # 锁定参数副本
        self.start_time = datetime.now()
        self.is_active = True
        self.processed_frames = 0

    def get_locked_parameter(self, key: str, default: Any = None) -> Any:
        """获取锁定的参数值"""
        return self.parameters.get(key, default)

    def end_session(self):
        """结束会话"""
        self.is_active = False
        self.end_time = datetime.now()

class FollowInstructionManager:
    def __init__(self):
        self.current_session: Optional[FollowInstructionSession] = None
        self.session_history: List[FollowInstructionSession] = []

    def start_session(self, algorithm: str, parameters: Dict[str, Any]) -> str:
        """开始新的遵循指令会话"""
        # 如果已有活跃会话，先结束它
        if self.current_session and self.current_session.is_active:
            self.end_session()

        self.current_session = FollowInstructionSession(algorithm, parameters)
        logger.info(f"开始遵循指令会话: {self.current_session.session_id}")
        logger.info(f"算法: {algorithm}, 参数: {parameters}")

        return self.current_session.session_id

    def end_session(self):
        """结束当前遵循指令会话"""
        if self.current_session and self.current_session.is_active:
            self.current_session.end_session()
            self.session_history.append(self.current_session)
            logger.info(f"结束遵循指令会话: {self.current_session.session_id}")
            self.current_session = None

    def get_locked_parameters(self) -> Optional[Dict[str, Any]]:
        """获取当前锁定的参数"""
        if self.current_session and self.current_session.is_active:
            return self.current_session.parameters.copy()
        return None

    def is_active(self) -> bool:
        """检查是否有活跃的遵循指令会话"""
        return self.current_session and self.current_session.is_active

    def get_session_info(self) -> Optional[Dict[str, Any]]:
        """获取当前会话信息"""
        if self.current_session and self.current_session.is_active:
            return {
                'session_id': self.current_session.session_id,
                'algorithm': self.current_session.algorithm,
                'start_time': self.current_session.start_time.isoformat(),
                'processed_frames': self.current_session.processed_frames,
                'parameters': self.current_session.parameters
            }
        return None

# 全局管理器实例
follow_instruction_manager = FollowInstructionManager()
```

### 分析接口修改

```python
# 在 samus_inference.py 中修改分析方法
def segment_with_follow_instruction(
    self,
    image: np.ndarray,
    roi: ROIRegion,
    user_parameters: Optional[Dict[str, float]] = None
) -> np.ndarray:
    """
    带遵循指令支持的分割方法
    """
    # 获取遵循指令状态
    follow_instruction_active = follow_instruction_manager.is_active()

    if follow_instruction_active:
        # 使用锁定的参数，忽略用户传入的参数
        locked_params = follow_instruction_manager.get_locked_parameters()
        if locked_params:
            logger.info(f"使用遵循指令锁定参数: {locked_params}")
            result = self.segment(image, roi, locked_params)

            # 更新处理帧数
            follow_instruction_manager.current_session.processed_frames += 1
            return result
        else:
            logger.warning("遵循指令活跃但无锁定参数，使用默认参数")

    # 正常处理流程（无遵循指令或遵循指令未激活）
    return self.segment(image, roi, user_parameters)
```

## 配置管理

### 默认遵循指令配置

```yaml
# follow_instruction_config.yaml
default_algorithms:
  enhanced_cv:
    name: "增强CV算法"
    parameters:
      frangi_threshold: 0.04
      frangi_scale_min: 1.5
      frangi_scale_max: 5.0
      area_min: 300.0
      area_max: 3500.0
      morph_kernel_size: 5

  elliptical_morph:
    name: "椭圆形态学算法"
    parameters:
      threshold_min: 50
      threshold_max: 150
      morph_strength: 0.5
      preprocessing_enabled: 1

  samus:
    name: "SAMUS深度学习算法"
    parameters:
      threshold: 0.5
      model_path: null

ui_settings:
  auto_hide_controls: true      # 遵循指令时自动隐藏控制面板
  show_progress_bar: true       # 显示处理进度
  highlight_locked_params: true  # 高亮显示锁定参数

session_settings:
  max_duration_minutes: 60      # 最大会话时长
  auto_save_results: true       # 自动保存结果
  session_log_level: "INFO"     # 会话日志级别
```

## 使用场景

### 1. 临床标准化检测
- **用途**: 确保不同患者的检测使用相同参数
- **优势**: 提高检测结果的一致性和可比性
- **配置**: 预设临床验证过的标准参数

### 2. 批量处理
- **用途**: 处理大量相似的超声图像
- **优势**: 减少人工干预，提高处理效率
- **配置**: 适合批量数据的通用参数

### 3. 培训和教学
- **用途**: 展示标准检测流程
- **优势**: 学员可以看到一致的分析过程
- **配置**: 教学用的演示参数

### 4. 质量控制
- **用途**: 确保检测质量符合标准
- **优势**: 避免参数调整导致的结果偏差
- **配置**: 质量控制标准参数

## 用户交互流程

### 启动遵循指令
1. 用户选择要使用的算法
2. 调整算法参数至满意状态
3. 点击"遵循指令"按钮
4. 系统锁定当前参数并开始自动分析
5. UI界面相应调整（隐藏/禁用参数控制）

### 执行期间
1. 系统使用锁定参数进行每帧分析
2. 实时显示分析结果和处理进度
3. 用户可以查看结果但无法修改参数
4. 可以随时点击"结束"按钮停止遵循指令

### 结束遵循指令
1. 用户点击"结束"按钮或系统自动结束
2. 参数锁定解除，恢复手动控制
3. UI界面恢复到正常状态
4. 系统保存会话记录和结果

## 状态同步机制

### 前端状态同步
```typescript
// WebSocket连接用于实时状态同步
const FollowInstructionSync = () => {
  const [status, setStatus] = useState<FollowInstructionStatus>();

  useEffect(() => {
    const ws = new WebSocket('ws://localhost:8001/ws/follow-instruction');

    ws.onmessage = (event) => {
      const data = JSON.parse(event.data);
      setStatus(data);

      // 更新UI状态
      updateUIBasedOnStatus(data);
    };

    return () => ws.close();
  }, []);

  const updateUIBasedOnStatus = (status: FollowInstructionStatus) => {
    // 更新按钮状态
    // 更新参数控件可用性
    // 更新进度指示器
    // 更新结果显示
  };
};
```

### 后端状态广播
```python
# websocket_manager.py
from fastapi import WebSocket
import json

class FollowInstructionWebSocketManager:
    def __init__(self):
        self.active_connections: List[WebSocket] = []

    async def connect(self, websocket: WebSocket):
        await websocket.accept()
        self.active_connections.append(websocket)

    def disconnect(self, websocket: WebSocket):
        self.active_connections.remove(websocket)

    async def broadcast_status(self, status: Dict[str, Any]):
        """广播遵循指令状态到所有连接的客户端"""
        message = json.dumps(status)
        for connection in self.active_connections:
            try:
                await connection.send_text(message)
            except:
                # 连接已断开，移除
                self.active_connections.remove(connection)

# 状态变化时广播
async def notify_follow_instruction_status_change():
    """通知前端遵循指令状态变化"""
    status = follow_instruction_manager.get_session_info()
    await websocket_manager.broadcast_status({
        'type': 'follow_instruction_status',
        'status': status,
        'timestamp': datetime.now().isoformat()
    })
```

## 日志和监控

### 会话日志
```python
# 会话开始日志
logger.info(f"遵循指令会话开始 - ID: {session_id}, 算法: {algorithm}, 参数: {parameters}")

# 参数锁定日志
for key, value in parameters.items():
    logger.debug(f"参数锁定: {key} = {value}")

# 处理进度日志
logger.info(f"帧处理进度: {processed_frames}/{total_frames} ({progress:.1f}%)")

# 会话结束日志
duration = end_time - start_time
logger.info(f"遵循指令会话结束 - ID: {session_id}, 时长: {duration}, 处理帧数: {processed_frames}")
```

### 性能监控
```python
# 处理时间统计
processing_times = []
if len(processing_times) > 0:
    avg_time = sum(processing_times) / len(processing_times)
    logger.info(f"平均帧处理时间: {avg_time:.3f}s")
    logger.info(f"处理速度: {1/avg_time:.1f} FPS")

# 内存使用监控
import psutil
memory_usage = psutil.Process().memory_info().rss / 1024 / 1024  # MB
logger.info(f"内存使用: {memory_usage:.1f} MB")
```

## 错误处理和恢复

### 常见错误处理
```python
class FollowInstructionError(Exception):
    """遵循指令相关错误基类"""
    pass

class InvalidParametersError(FollowInstructionError):
    """无效参数错误"""
    pass

class SessionTimeoutError(FollowInstructionError):
    """会话超时错误"""
    pass

# 错误处理示例
def handle_follow_instruction_error(error: Exception):
    if isinstance(error, InvalidParametersError):
        logger.error(f"遵循指令参数错误: {error}")
        # 恢复默认参数
        return get_default_parameters()
    elif isinstance(error, SessionTimeoutError):
        logger.warning(f"遵循指令会话超时: {error}")
        # 自动结束会话
        follow_instruction_manager.end_session()
        return None
    else:
        logger.error(f"遵循指令未知错误: {error}")
        # 结束会话并重置
        follow_instruction_manager.end_session()
        raise error
```

## 测试策略

### 单元测试
```python
# test_follow_instruction.py
import pytest
from follow_instruction_manager import FollowInstructionManager

def test_start_session():
    manager = FollowInstructionManager()
    session_id = manager.start_session("enhanced_cv", {"threshold": 0.5})
    assert session_id is not None
    assert manager.is_active() is True

def test_parameter_locking():
    manager = FollowInstructionManager()
    manager.start_session("elliptical_morph", {"threshold_min": 50, "threshold_max": 150})

    locked_params = manager.get_locked_parameters()
    assert locked_params["threshold_min"] == 50
    assert locked_params["threshold_max"] == 150

def test_session_ending():
    manager = FollowInstructionManager()
    session_id = manager.start_session("samus", {"threshold": 0.7})
    manager.end_session()

    assert manager.is_active() is False
    assert len(manager.session_history) == 1
```

### 集成测试
```python
def test_follow_instruction_workflow():
    """测试完整的遵循指令工作流程"""
    # 1. 启动会话
    response = client.post("/api/follow-instruction", json={
        "algorithm": "enhanced_cv",
        "parameters": {"frangi_threshold": 0.04},
        "enable": True
    })
    assert response.status_code == 200

    # 2. 检查状态
    status_response = client.get("/api/follow-instruction/status")
    assert status_response.json()["is_active"] is True

    # 3. 执行分析
    # ... 测试分析过程 ...

    # 4. 结束会话
    response = client.post("/api/follow-instruction", json={
        "enable": False
    })
    assert response.status_code == 200
```

## 总结

"遵循指令"功能是VeinDetector系统中的重要特性，它通过参数锁定和自动化执行提高了检测的一致性和效率。该功能特别适用于需要标准化检测的场景，如临床诊断、批量处理和质量控制等。

通过完善的会话管理、状态同步、错误处理和测试机制，确保了该功能的稳定性和可靠性。同时，灵活的配置选项和用户友好的界面设计，使得用户可以轻松地启用和控制遵循指令模式。